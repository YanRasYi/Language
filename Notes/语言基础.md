constexpr表达式是指值不会改变并且在编译过程就能得到计算结果的表达式

初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。
作用域：C++里作用域可分为6种：全局，局部，类，语句，命名空间和文件作用域。 
全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。
静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。
局部变量：局部作用域，比如函数的参数，函数内的局部变量等等。
静态局部变量 ：局部作用域，只被初始化一次，直到程序结束。 

赋值顺序不同：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。
效率不同：后置++执行速度比前置的慢。
i++ 不能作为左值，而++i 可以

说说new和malloc的区别，各自底层实现原理？
    new是操作符，而malloc是函数。
    new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
    malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
    new可以被重载；malloc不行
    new分配内存更直接和安全。
    new发生错误抛出异常，malloc返回null

 malloc底层实现：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。
 采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。
 new底层实现：关键字new在调用构造函数的时候实际上进行了如下的几个步骤：
    创建一个新的对象
    将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
    执行构造函数中的代码（为这个新对象添加属性）
    返回新对象


const生效于编译的阶段；define生效于预处理阶段。
const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。


指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数


说说const int *a, int const *a, const int a, int *const a, const int *const a分别是什么，有什么特点。
1. const int a;     //指的是a是一个常量，不允许修改。
2. const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
3. int const *a;    //同const int *a;
4. int *const a;    //a指针所指向的内存地址不变，即a不变
5. const int *const a;   //都不变，即（*a）不变，a也不变


简述const（星号）和（星号）const的区别
//const* 是常量指针，*const 是指针常量
int const *a;    //a指针所指向的内存里的值不变，即（*a）不变
int *const a;    //a指针所指向的内存地址不变，即a不变

